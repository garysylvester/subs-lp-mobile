import * as React from 'react';
import {PropertyControls, ControlType, Frame, FrameProperties, Color} from 'framer';

import {Transitions, ITransition, ITransitionFrame, ITransitionOptions} from './Transitions';

interface IRouteStackItem {
    frame: any;
    index: number;
    transition: ITransition;
}

interface IRouterProps extends FrameProperties {
    routes: any[];
    onMount(Router): void;
    onTransitionStart(Router, index): void;
    onTransitionEnd(Router, index): void;
    background: Color;
}

interface IRouterState {
    previousRoute: any;
    currentRoute: any;
    transition: ITransition;
    stack: IRouteStackItem[];
    direction: string;
}

export class Router extends React.Component<IRouterProps, IRouterState> {

    // STATICS

    static defaultProps: Partial<IRouterProps> = {
        routes: [],
        onMount: () => null,
        onTransitionStart: () => null,
        onTransitionEnd: () => null,
        background: Color('#000')
    }

    static propertyControls: PropertyControls = {
        background: {
            title: 'Background',
            type: ControlType.Color
        },
        perspective: {
            title: 'Perspecitve',
            type: ControlType.Number,
            min: 0,
            max: 8000,
            step: 100,
            defaultValue: 0
        },
        routes: {
            title: 'Routes',
            type: ControlType.Array,
            propertyControl: {
                type: ControlType.ComponentInstance
            }
        }
    }

    constructor(props: IRouterProps) {
        super(props);

        this.state = {
            previousRoute: null,
            currentRoute: null,
            transition: null,
            stack: [],
            direction: 'forward'
        }
    }
    

    // LIFECYCLE

    componentDidMount() {
        this.props.routes[0] ? this.transition(0) : null;
        this.props.onMount(this);
    }

    // PRIVATE

    private buildRoute(route) {
        const {width, height} = this.props;

        return React.cloneElement(route, {
            ...route.props,
            width,
            height,
            top: 0,
            left: 0,
            opacity: 1
        });
    }

    // PUBLIC

    public transition(routeIndex: number, transition?: Function) {
        const newRoute = this.buildRoute(this.props.routes[routeIndex]);

        if (newRoute === this.state.currentRoute) return;

        const trans: ITransition = transition ? transition(this.props) : Transitions.dissolve(this.props);

        const newStack = this.state.stack.slice();

        newStack.push({
            frame: newRoute,
            transition: trans,
            index: routeIndex
        });

        this.setState({
            previousRoute: this.state.currentRoute,
            currentRoute: newRoute,
            transition: trans,
            stack: newStack,
            direction: 'forward'
        }, () => {
            this.props.onTransitionStart(this, routeIndex);

            setTimeout(() => this.props.onTransitionEnd(this, routeIndex), trans.frameB.options.time * 1000);
        });
    }

    public transitionPrevious() {
        if (!(this.state.stack.length > 1)) return;

        const {frame: previousRoute, transition} = this.state.stack.slice(-1).pop();
        const newStack = this.state.stack.slice(0, -1);
        const {frame: currentRoute} = newStack.slice(-1).pop();
        
        this.setState({
            previousRoute,
            currentRoute,
            transition,
            stack: newStack,
            direction: 'back'
        }, () => {
            this.props.onTransitionStart(this, newStack[newStack.length - 1]);

            setTimeout(() => this.props.onTransitionEnd(this, newStack[newStack.length - 1]), this.state.transition.frameB.options.time * 1000);
        });
    }

    render() {
        const {width, height} = this.props;
        const {direction, transition} = this.state;

        let frames = null;

        if (this.state.previousRoute) {
            frames = [
                (
                    <Mover
                        hide
                        width={width}
                        height={height}
                        transition={direction === 'forward' ? transition.frameA : transition.frameB}
                        key={`previous_${this.state.previousRoute.props.id}`}
                    >
                        {this.state.previousRoute}
                    </Mover>
                ), 
                (
                    <Mover
                        show
                        width={width}
                        height={height}
                        transition={direction === 'forward' ? transition.frameB : transition.frameA}
                        key={`current_${this.state.currentRoute.props.id}`}
                    >
                        {this.state.currentRoute}
                    </Mover>
                )
            ]
        } else if (this.state.currentRoute) {
            frames = [
                <Mover
                    show
                    width={width}
                    height={height}
                    transition={direction === 'forward' ? transition.frameB : transition.frameA}
                    key={`current_${this.state.currentRoute.props.id}`}
                >
                    {this.state.currentRoute}
                </Mover>
            ]
        }

        return (
            <Frame
                width={width}
                height={height}
                background={this.props.background}
                perspective={this.props.perspective}
                overflow="hidden"
            >
                {frames}
            </Frame>
        );
    }
}


interface IMoverProps extends FrameProperties {
    transition: ITransitionFrame;
    show: boolean;
    hide: boolean;
}

class Mover extends React.Component<Partial<IMoverProps>> {

    state = {
        style: null
    }

    componentDidMount() {
        this.transition(this.props);
    }

    componentWillReceiveProps(props) {
        this.transition(props);
    }

    private setTransition(transition: ITransitionFrame) {
        const transitionTarget = this.props.show ? transition.show : transition.hide;

        setTimeout(() => {
            this.setState({
                style: {
                    ...transitionTarget
                }
            });
        }, 0);
    }

    private transition(props: Partial<IMoverProps>) {
        this.setTransition(props.transition);
    }

    render() {
        const {width, height, children, show, transition} = this.props;
        const {style} = this.state;

        const initialStyle = show ? transition.hide : transition.show;

        return (
            <Frame
                style={{
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    'transition': `all ${transition.options.time}s`
                }}
                height={height}
                width={width}
                background={null}
                {...initialStyle}
                {...style}
            >
                {children}
            </Frame>
        );
    }
}