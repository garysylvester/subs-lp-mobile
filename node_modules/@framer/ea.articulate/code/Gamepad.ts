import * as EventEmitter from 'eventemitter3';
import * as _ from 'lodash';

export interface IGamepadEvent {
    type: string;
    keyCode: number;
    value?: number;
}

interface IGamepad {
    throttle: boolean;
    connectedGamepad: any;
    loopRequest: number;
    buttonsPressed: {}[];
    loopInterval: number;
    axisSensitivity: number;
    eventsInSequence: number;
    initializeGamepad(): void;
    initializeLoop(): void;
    setupEventListeners(): void;
    assignKeyCodeToAxis(index: number, value: number): number;
    updateLoop(): void;
}

export class Gamepad extends EventEmitter implements IGamepad {

    throttle: boolean;
    connectedGamepad: any;
    loopRequest: number;
    buttonsPressed: {}[];
    loopInterval: number;
    axisSensitivity: number;
    eventsInSequence: number;
    
    constructor(throttle: boolean) {
        super();

        this.connectedGamepad = this.initializeGamepad();
        this.loopRequest = this.initializeLoop();

        this.buttonsPressed = [];
        this.loopInterval = 500;
        this.throttle = throttle;
        this.axisSensitivity = this.throttle ? .7 : .2;
        this.eventsInSequence = 0;
        
        this.setupEventListeners();
    }

    initializeGamepad() {
        if (navigator.getGamepads && navigator.getGamepads()[0]) {
            return navigator.getGamepads()[0];
        }
    }

    initializeLoop() {
        return window.requestAnimationFrame(this.updateLoop.bind(this));
    }

    setupEventListeners() {
        window.addEventListener('gamepadconnected', (e) => {
            this.connectedGamepad = this.initializeGamepad();
            this.loopRequest = this.initializeLoop();
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            this.connectedGamepad = null;
            window.cancelAnimationFrame(this.loopRequest);
        });
    }

    assignKeyCodeToAxis(index: number, value: number) {
        switch(index) {
            case 0:
                return value > 0 ? 39 : 37;
            case 1:
                return value > 0 ? 40 : 38;
            case 2:
                return value > 0 ? 44 : 42;
            case 3:
                return value > 0 ? 43 : 41;
        }
    }

    updateLoop() {
        if (!this.connectedGamepad) return;

        setTimeout(() => {
            const pollingGP: any = navigator.getGamepads()[0];

            pollingGP.buttons.forEach((button, index) => {
                button.type = 'button';
                button.keyCode = index;
            });

            this.buttonsPressed = _.filter(pollingGP.buttons, {pressed: true});

            pollingGP.axes.forEach((axis, index) => {
                if (index <= 3) {
                    let activeAxis: IGamepadEvent = null;

                    if (axis > this.axisSensitivity || axis < -this.axisSensitivity) {
                        activeAxis = {
                            type: 'axis',
                            value: axis,
                            keyCode: this.assignKeyCodeToAxis(index, axis)
                        }

                        this.buttonsPressed.push(activeAxis);
                    }
                }
            });

            if (this.buttonsPressed.length) {
                this.buttonsPressed.forEach(buttonPressed => {
                    this.emit('gamepadevent', buttonPressed);
                });

                if (this.throttle) {
                    if (this.eventsInSequence === 0) {
                        this.loopInterval = 3;
                    } else if (this.eventsInSequence === 1) {
                        this.loopInterval = 8;
                    }
                } else {
                    this.loopInterval = 1000;
                }

                this.eventsInSequence++;
            } else {
                if (this.throttle) {
                    this.eventsInSequence = 0;
                    this.loopInterval = 500
                } else {
                    this.eventsInSequence = 0;
                    this.loopInterval = 1000;
                }
            }

            this.loopRequest = window.requestAnimationFrame(this.updateLoop.bind(this));

        }, this.loopInterval / 1000);
    }
}