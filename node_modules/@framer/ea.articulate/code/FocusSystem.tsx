import * as React from 'react';
import {Frame, FrameProperties, Point, Background} from 'framer';
import * as EventEmitter from 'eventemitter3';
import * as _ from 'lodash';

import {Focusable} from './Focusable.tsx';
import {Gamepad, IGamepadEvent} from './Gamepad';

const FocusContext = React.createContext({
    focused: null
});

const FocusProvider = FocusContext.Provider;
export const FocusConsumer = FocusContext.Consumer;


interface IFocusSystemProps extends FrameProperties {
    onFocus(focusable): void;
    onFocusables(focusables): void;
}

interface IFocusSystemState {
    focusables: any[];
    focused: any;
    previouslyFocused: any;
}

export class FocusSystem extends React.Component<IFocusSystemProps, IFocusSystemState> {

    gamepad: Gamepad;

    static defaultProps: Partial<IFocusSystemProps> = {
        onFocus: (focusable) => null,
        onFocusables: (focusables) => null
    }

    constructor(props) {
        super(props);

        this.gamepad = new Gamepad(true);

        this.gamepad.on('gamepadevent', this.handleGamepadInput.bind(this));
        window.addEventListener('keydown', this.handleKeyboardInput.bind(this));

        this.state = {
            focusables: [],
            focused: null,
            previouslyFocused: null
        }
    }

    // LIFECYCLE

    componentWillReceiveProps(nextProps) {
        if (this.props.children !== nextProps.children) {
            this.findFirstFocusable(nextProps.children);
        }
    }

    // PRIVATE

    private handleGamepadInput(e: IGamepadEvent) {
        this.handleKeyboardInput(e);

        if (e.keyCode > 11 && e.keyCode < 16 && this.hasFocusables) {
            this.navigate(e.keyCode);
        }
    }

    private handleKeyboardInput(e: KeyboardEvent | IGamepadEvent) {
        if (e.keyCode > 36 && e.keyCode < 41 && this.hasFocusables) {
            this.navigate(e.keyCode);
        }
    }

    private navigate(keyCode: number) {
        if (!this.state.focused) return;

        const focusedPosition = this.calculatePosition(this.state.focused);

        const relevantFocusables = this.state.focusables.filter(focusable => {
            if (!focusable.props.focusable || !focusable.props.visible || focusable.props.opacity === 0) return false;

            let focusablePosition = this.calculatePosition(focusable);

            switch(keyCode) {
                case 13 || 37:
                    return focusablePosition.x + (focusable.props.width / 2) < focusedPosition.x ? 
                    true : false;
                case 11 || 38:
                    return focusablePosition.y + (focusable.props.height / 2) < focusedPosition.y ? 
                    true : false;
                case 14 || 39:
                    return focusablePosition.x - (focusable.props.width / 2) > focusedPosition.x ? 
                    true : false;
                case 12 || 40:
                    return focusablePosition.y - (focusable.props.height / 2) > focusedPosition.y ? 
                    true : false;
            }
        });

        const sortedFocusables = _.sortBy(relevantFocusables, focusable => {
            let angleOffset;

            switch(keyCode) {
                case 13 || 37:
                    angleOffset = 90;
                    break;
                case 11 || 38:
                    angleOffset = 0;
                    break;
                case 14 || 39:
                    angleOffset = 90;
                    break;
                case 12 || 40:
                    angleOffset = 180;
                    break;
            }

            let focusablePosition = this.calculatePosition(focusable);

            const distance = this.calculateDistance(focusedPosition, focusablePosition);
            const angle = this.calculateAngle(focusedPosition, focusablePosition);
            const score = this.calculateScore(distance, angleOffset, angle);

            return score;
        });

        if (sortedFocusables.length) {
            this.setState({
                focused: sortedFocusables[0],
                previouslyFocused: this.state.focused
            }, () => {
                this.props.onFocus(this.state.focused);
            });
        }
    }

    private calculatePosition(focusable: any): Point {
        const {centerX, centerY} = focusable.props;

        console.log(focusable)

        const center = {
            x: parseFloat(centerX.substr(0, centerX.length - 1)) / 100,
            y: parseFloat(centerY.substr(0, centerY.length - 1)) / 100
        }

        return center;
    }

    private calculateDistance(pointA: Point, pointB: Point) {
        const xDelta = Math.abs(pointA.x - pointB.x);
        const yDelta = Math.abs(pointA.y - pointB.y);

        return Math.sqrt(Math.abs((xDelta * xDelta) + (yDelta * yDelta)));
    }

    private calculateAngle(pointA: Point, pointB: Point) {
        const xDelta = pointA.x - pointB.x;
        const yDelta = pointA.y - pointB.y;
        const atan2 = Math.atan2(xDelta, yDelta);

        return Math.abs(atan2 * 180 / Math.PI);
    }

    private calculateScore(distance: number, angleOffset: number, angle: number) {
        return distance + Math.abs(angleOffset - angle);
    }

    private findFirstFocusable(children) {
        return React.Children.map(children, (child: React.ReactElement<FrameProperties>) => {
            if (!React.isValidElement(child)) return child;

            if ((child as any).props.focusable) {
                this.setState({
                    focused: child,
                    focusables: [...this.state.focusables, child]
                });
            }

            if ((child as any).props.children) {
                return child = React.cloneElement(child as React.ReactElement<any>, {
                    children: this.findFirstFocusable((child as any).props.children)
                });
            }
        });
    }

    // GETTERS & SETTERS

    public get hasFocusables() {
        return !!this.state.focusables.length;
    }

    render() {
        const {width, height, background} = this.props;

        return (
            <FocusProvider value={{focused: this.state.focused}}>
                <Frame
                    width={width}
                    height={height}
                    background={background}
                    overflow="hidden"
                >
                    {this.props.children}
                </Frame>
            </FocusProvider>
        );
    }
}